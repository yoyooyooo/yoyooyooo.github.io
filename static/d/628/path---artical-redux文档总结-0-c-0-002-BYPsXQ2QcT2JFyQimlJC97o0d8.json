{"data":{"site":{"siteMetadata":{"title":"yoyo","author":"yoyo"}},"markdownRemark":{"id":"35892410-00a2-59a2-b05a-d17e553d81ff","excerpt":"概念 store ：(也称为 state tree) 是一个宽泛的概念， 但是在 Redux API 中，通常是指一个唯一的 state 值，由 store 管理且由 getState() 方法获得。它表示了 Redux 应用的全部状态，通常为一个多层嵌套的对象。约定俗成，顶层 state 或为一个对象，或像 Map…","html":"<h1>概念</h1>\n<p><strong>store</strong>：(也称为 state tree) 是一个宽泛的概念， 但是在 Redux API 中，通常是指一个唯一的 state 值，由 store 管理且由 getState() 方法获得。它表示了 Redux 应用的全部状态，通常为一个多层嵌套的对象。约定俗成，顶层 state 或为一个对象，或像 Map 那样的键-值集合，也可以是任意的数据类型。然而你应尽可能确保 state 可以被序列化，而且不要把什么数据都放进去，导致无法轻松地把 state 转换成 JSON。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">type Store <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n\n  dispatch<span class=\"token punctuation\">:</span> Dispatch\n\n  getState<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> State\n\n  subscribe<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span>listener<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span>\n\n  replaceReducer<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span>reducer<span class=\"token punctuation\">:</span> Reducer<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span>\n\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Store 维持着应用的 state tree 对象。 因为应用的构建发生于 reducer，所以一个 Redux 应用中应当只有一个 Store。</p>\n<ul>\n<li>dispatch(action)  是上述的 base dispatch function。</li>\n<li>getState()  返回当前 store 的 state。</li>\n<li>subscribe(listener)  注册一个 state 发生变化时的回调函数。</li>\n<li>replaceReducer(nextReducer)  可用于热重载和代码分割。通常你不需要用到这个 API。</li>\n</ul>\n<p><strong>action</strong> ：一个普通对象，用来表示即将改变 state 的意图，它是将数据放入 store (改变 state)的唯一途径。无论是从 UI 事件、网络回调，还是其他诸如 WebSocket 之类的数据源所获得的数据，最终都会被 dispatch 成 action。约定俗成，action 必须拥有一个  type  域，它指明了需要被执行的 action type。Type 可以被定义为常量，然后从其他 module 导入。比起用  Symbols  表示  type，使用 String 是更好的方法，因为 string 可以被序列化。除了  type  之外，action 对象的结构其实完全取决于你自己。</p>\n<p><strong>reducers</strong>：描述 action 如何改变 state 树。\n<code class=\"language-text\">type Reducer&lt;S, A&gt; = (state: S, action: A) =&gt; S</code>\nReducer (也称为 reducing function) 函数接受两个参数：之前累积运算的结果和当前被累积的值，返回的是一个新的累积结果。该函数把一个集合归并成一个单值。\nReducer 并不是 Redux 特有的函数 —— 它是函数式编程中的一个基本概念，甚至大部分的非函数式语言比如 JavaScript，都有一个内置的 reduce API。对于 JavaScript，这个 API 是 Array.prototype.reduce().\n在 Redux 中，累计运算的结果是 state 对象，而被累积的值是 action。Reducer 由上次累积的结果 state 与当前被累积的 action 计算得到一个新 state。这些 Reducer 必须是纯函数，而且当输入相同时返回的结果也会相同。它们不应该产生任何副作用。</p>\n<p><strong>dispatch 函数</strong>：\n<code class=\"language-text\">type BaseDispatch = (a: Action) =&gt; Action</code></p>\n<p><code class=\"language-text\">type Dispatch = (a: Action | AsyncAction) =&gt; any</code>\ndispatching function (或简言之  dispatch function) 是一个接收 action 或者异步 action 的函数，该函数要么往 store 分发一个或多个 action，要么不分发任何 action。</p>\n<p><strong>Action Creator</strong>：一个创建 action 的函数。\n<code class=\"language-text\">type ActionCreator = (...args: any) =&gt; Action | AsyncAction</code>\nAction 是一个信息的负载，而 action creator 是一个创建 action 的工厂。调用 action creator 只会生产 action，但不分发。你需要调用 store 的  dispatch function 才会引起变化。有时我们讲  bound action creator，是指一个函数调用了 action creator 并立即将结果分发给一个特定的 store 实例。如果 action creator 需要读取当前的 state、调用 API、或引起诸如路由变化等副作用，那么它应该返回一个异步 action 而不是 action。</p>\n<p><strong>异步 Action</strong>：一个发给 dispatching 函数的值，但是这个值还不能被 reducer 消费。在发往 base dispatch() function 之前，middleware  会把异步 action 转换成一个或一组 action。异步 action 可以有多种 type，这取决于你所使用的 middleware。它通常是 Promise 或者 thunk 之类的异步原生数据类型，虽然不会立即把数据传递给 reducer，但是一旦操作完成就会触发 action 的分发事件。</p>\n<p><strong>Middleware</strong>：\n<code class=\"language-text\">type MiddlewareAPI = { dispatch: Dispatch, getState: () =&gt; State }</code> <code class=\"language-text\">type Middleware = (api: MiddlewareAPI) =&gt; (next: Dispatch) =&gt; Dispatch</code>\nMiddleware 是一个组合  dispatch function  的高阶函数，返回一个新的 dispatch function，通常将异步 actions  转换成 action。\nMiddleware 利用复合函数使其可以组合其他函数，可用于记录 action 日志、产生其他诸如变化路由的副作用，或将异步的 API 调用变为一组同步的 action。<a href=\"http://www.redux.org.cn/docs/api/applyMiddleware.html\">详情</a></p>\n<hr>\n<p><strong>应该把要做的修改变成一个普通对象(action)，而不是直接修改 state。然后编写专门的函数(reducer)来决定每个 action 如何改变应用的 tate。</strong></p>\n<p>Redux 没有 Dispatcher 且不支持多个 store。相反，只有一个单一的 store 和一个根级的 reduce 函数（reducer）。随着应用不断变大，你应该把根级的 reducer 拆成多个小的 reducers，分别独立地操作 state 树的不同部分，而不是添加新的 stores。这就像一个 React 应用只有一个根级的组件，这个根组件又由很多小组件构成。</p>\n<p><strong>redux 三大原则</strong>：</p>\n<ul>\n<li><strong>单一数据源</strong>：整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。</li>\n<li><strong>State 是只读的</strong>：惟一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。</li>\n<li><strong>使用纯函数来执行修改</strong>：为了描述 action 如何改变 state tree ，你需要编写 reducers。</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> createStore <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'redux'</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">/**\n * 这是一个 reducer，形式为 (state, action) => state 的纯函数。\n * 描述了 action 如何把 state 转变成下一个 state。\n * state 的形式取决于你，当state变化时需要返回全新的对象，而不是修改传入的参数。\n * 下面例子使用 `switch` 语句和字符串来做判断，但你可以写帮助类(helper)\n * 根据不同的约定（如方法映射）来判断，只要适用你的项目即可。\n */</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">counter</span><span class=\"token punctuation\">(</span>state <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> action<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>action<span class=\"token punctuation\">.</span>type<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">case</span> <span class=\"token string\">'INCREMENT'</span><span class=\"token punctuation\">:</span>\n      <span class=\"token keyword\">return</span> state <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">case</span> <span class=\"token string\">'DECREMENT'</span><span class=\"token punctuation\">:</span>\n      <span class=\"token keyword\">return</span> state <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">default</span><span class=\"token punctuation\">:</span>\n      <span class=\"token keyword\">return</span> state<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 创建 Redux store 来存放应用的状态。</span>\n<span class=\"token comment\">// API 是 { subscribe, dispatch, getState }。</span>\n<span class=\"token keyword\">let</span> store <span class=\"token operator\">=</span> <span class=\"token function\">createStore</span><span class=\"token punctuation\">(</span>counter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 可以手动订阅更新，也可以事件绑定到视图层。</span>\nstore<span class=\"token punctuation\">.</span><span class=\"token function\">subscribe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>store<span class=\"token punctuation\">.</span><span class=\"token function\">getState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 改变内部 state 惟一方法是 dispatch 一个 action。</span>\n<span class=\"token comment\">// action 可以被序列化，用日记记录和储存下来，后期还可以以回放的方式执行</span>\nstore<span class=\"token punctuation\">.</span><span class=\"token function\">dispatch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> type<span class=\"token punctuation\">:</span> <span class=\"token string\">'INCREMENT'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 1</span>\nstore<span class=\"token punctuation\">.</span><span class=\"token function\">dispatch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> type<span class=\"token punctuation\">:</span> <span class=\"token string\">'INCREMENT'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 2</span>\nstore<span class=\"token punctuation\">.</span><span class=\"token function\">dispatch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> type<span class=\"token punctuation\">:</span> <span class=\"token string\">'DECREMENT'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 1</span></code></pre></div>\n<blockquote>\n<p>未完待续</p>\n</blockquote>","frontmatter":{"title":"redux文档整理","date":"2017.12.19"}}},"pageContext":{"slug":"/artical/redux文档总结/","previous":{"fields":{"slug":"/artical/js实用函数之array/"},"frontmatter":{"title":"js实用函数之array"}},"next":{"fields":{"slug":"/artical/js实用函数之杂/"},"frontmatter":{"title":"js实用方法之杂"}}}}
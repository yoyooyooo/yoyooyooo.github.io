{"data":{"site":{"siteMetadata":{"title":"yoyo","author":"yoyo"}},"markdownRemark":{"id":"d07fd3fd-846f-59ff-a868-4d34b34575df","excerpt":"功能 适用操作符 把多个操作符以头尾相连的方式合并 concat 、 concatAll 把多个操作符以先到先得的方式合并 merge 、 mergeAll 把多个操作符以一一对应的方式合并 zip 、 zipAll 持续合并多个数据流中最新产生的数据 combineLastest 、 combineAll…","html":"<table>\n<thead>\n<tr>\n<th align=\"left\"><center>功能</center></th>\n<th align=\"left\"><center>适用操作符</center></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">把多个操作符以头尾相连的方式合并</td>\n<td align=\"left\"><a href=\"#concat\">concat</a>、<a href=\"#concatAll\">concatAll</a></td>\n</tr>\n<tr>\n<td align=\"left\">把多个操作符以先到先得的方式合并</td>\n<td align=\"left\"><a href=\"#merge\">merge</a>、<a href=\"#mergeAll\">mergeAll</a></td>\n</tr>\n<tr>\n<td align=\"left\">把多个操作符以一一对应的方式合并</td>\n<td align=\"left\"><a href=\"#zip\">zip</a>、<a href=\"#zipAll\">zipAll</a></td>\n</tr>\n<tr>\n<td align=\"left\">持续合并多个数据流中最新产生的数据</td>\n<td align=\"left\"><a href=\"#combineLastest\">combineLastest</a>、<a href=\"#conbineAll\">combineAll</a>、<a href=\"#withLatestFrom\">withLatestFrom</a></td>\n</tr>\n<tr>\n<td align=\"left\">从多个数据流中选取第一个产生内容的数据流</td>\n<td align=\"left\"><a href=\"#race\">race</a></td>\n</tr>\n<tr>\n<td align=\"left\">在数据流前面添加一个指定数据</td>\n<td align=\"left\"><a href=\"#startWith\">startWith</a></td>\n</tr>\n<tr>\n<td align=\"left\">只获取多个数据流最后产生的那个数据</td>\n<td align=\"left\"><a href=\"#forkJoin\">forkJoin</a></td>\n</tr>\n<tr>\n<td align=\"left\">从高阶数据流中切换数据源</td>\n<td align=\"left\"><a href=\"#switchAll\">switchAll</a>、<a href=\"#exhaust\">exhaust</a></td>\n</tr>\n</tbody>\n</table>\n<h1>concat</h1>\n<p>既有静态操作符也有实例操作符。<strong>首尾相连依次</strong>合并多条数据流。作为静态操作符时可以接收任意个参数，从第一个数据流开始，前一个 Observable 完结后，订阅下一个 Observable。如果某一个 Observable 永不完结，则后面的数据流永远没机会上场。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">//静态操作符</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> concat <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'rxjs'</span><span class=\"token punctuation\">;</span>\nconstsource1$ <span class=\"token operator\">=</span> <span class=\"token keyword\">of</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconstsource2$ <span class=\"token operator\">=</span> <span class=\"token keyword\">of</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconstsource$ <span class=\"token operator\">=</span> <span class=\"token function\">concat</span><span class=\"token punctuation\">(</span>source1$<span class=\"token punctuation\">,</span> source2$<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//123456</span>\n<span class=\"token comment\">//实例操作符</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> concat <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'rxjs/operators'</span><span class=\"token punctuation\">;</span>\nconstsource1$ <span class=\"token operator\">=</span> <span class=\"token keyword\">of</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconstsource2$ <span class=\"token operator\">=</span> <span class=\"token keyword\">of</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconstsource$ <span class=\"token operator\">=</span> source1$ <span class=\"token operator\">|</span><span class=\"token operator\">></span> <span class=\"token function\">concat</span><span class=\"token punctuation\">(</span>source2$<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//123456</span></code></pre></div>\n<blockquote>\n<p><strong>注意引用路径不同</strong>,如果一个 js 里要同时用 2 种 cancat，可以 import 的时候用 as 改名以示区分，如静态操作符改成大写开头：<code class=\"language-text\">import{concatasConcat}from&quot;rxjs&quot;</code></p>\n</blockquote>\n<h1>merge</h1>\n<p>既有静态操作符也有实例操作符。先到先得。第一时间订阅所有数据流，然后对上游数据采取“先到先得”策略，任何一个 Observable 只要有数据推下来，就会立刻转给下游 Observable，merge 只有在所有上游数据都完结后才会完结自己产生的 Observable 对象。(<strong>如果 2 个数据同时生成，先订阅的数据流会先吐数据</strong>)\n<strong>merge 一般用来合并异步数据</strong>，如果合并同步数据，它是依次订阅所有上游数据的，也就是说当它订阅了第一个数据流后还没来得及订阅第二个数据流，就把数据全吐出来了</p>\n<ul>\n<li>数据汇流</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> mergeasMerge <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'rxjs'</span><span class=\"token punctuation\">;</span>\nconstsource1$ <span class=\"token operator\">=</span> <span class=\"token function\">timer</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">|</span><span class=\"token operator\">></span> <span class=\"token function\">map</span><span class=\"token punctuation\">(</span>a <span class=\"token operator\">=></span> a <span class=\"token operator\">+</span> <span class=\"token string\">'A'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconstsource2$ <span class=\"token operator\">=</span> <span class=\"token function\">timer</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">|</span><span class=\"token operator\">></span> <span class=\"token function\">map</span><span class=\"token punctuation\">(</span>a <span class=\"token operator\">=></span> a <span class=\"token operator\">+</span> <span class=\"token string\">'B'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconstsource$ <span class=\"token operator\">=</span> <span class=\"token function\">Merge</span><span class=\"token punctuation\">(</span>source1$<span class=\"token punctuation\">,</span> source2$<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//1A1B2A2B3A3B...</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> mergeasMerge <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'rxjs'</span><span class=\"token punctuation\">;</span>\nconstsource1$ <span class=\"token operator\">=</span> <span class=\"token keyword\">of</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconstsource2$ <span class=\"token operator\">=</span> <span class=\"token keyword\">of</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconstsource$ <span class=\"token operator\">=</span> <span class=\"token function\">Merge</span><span class=\"token punctuation\">(</span>source1$<span class=\"token punctuation\">,</span> source2$<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//123456</span></code></pre></div>\n<ul>\n<li>\n<p>同步限流\nmerge 还可以接收一个可选参数，表示可以同时合并的 Observable 对象个数。比如<code class=\"language-text\">Merge(source1$,source2$,source3$,source4$,2)</code>，<strong>当 source1 和 source2 中的其中一条数据流完结了，source3 才会开始吐数据</strong>，如果 source1 和 source2 都永不完结，则后面的数据流永远没机会上场</p>\n</li>\n<li>\n<p>merge 应用场景通常情况下，我们一次只能从一个 DOM 元素获取一种类型事件，比如我们关心某个元素的 click 事件，同时也关心这个元素上的 touchend 事件，因为在移动设备上 touchend 出现的比 click 更早，这 2 个事件的处理是一模一样的，但是 fromEvent 不能同时获得 2 个事件的数据流，这时候可以用 merge。无论 click 事件发生还是 touchend 事件发生，都会流到 merge 产生的同一个 Observable 对象中，这样就可以统一用同一个事件处理函数 eventHandler 来处理。</p>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> merge <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'rxjs'</span><span class=\"token punctuation\">;</span>\nconstclick$ <span class=\"token operator\">=</span> <span class=\"token function\">fromEvent</span><span class=\"token punctuation\">(</span>elememt<span class=\"token punctuation\">,</span> <span class=\"token string\">'click'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsttouchend$ <span class=\"token operator\">=</span> <span class=\"token function\">fromEvent</span><span class=\"token punctuation\">(</span>elememt<span class=\"token punctuation\">,</span> <span class=\"token string\">'touchend'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">merge</span><span class=\"token punctuation\">(</span>click$<span class=\"token punctuation\">,</span> touchend$<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">subscribe</span><span class=\"token punctuation\">(</span>eventHandler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h1>zip</h1>\n<p>既有静态操作符也有实例操作符。<strong>一一对应</strong>合并数据流，就像拉链一样，吐出的数据会转化为数组的形式。当 zip 开始合并时，会立刻订阅上游所有数据流，zip 完结后会退订上游所有数据流。</p>\n<ul>\n<li>一对一合并\n<strong>注意：</strong>如果其中一条数据流是异步的，其他数据流会等待他吐出数据，严格遵守“一一对应”原则。只要合并的其中任何一条数据流完结了，zip 合并生成的 Observable 对象会在最后一次合并完成后完结。</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> zip <span class=\"token keyword\">as</span> Zip <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'rxjs'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> source1$ <span class=\"token operator\">=</span> <span class=\"token keyword\">of</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> source2$ <span class=\"token operator\">=</span> <span class=\"token keyword\">of</span><span class=\"token punctuation\">(</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'c'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> source$ <span class=\"token operator\">=</span> <span class=\"token function\">Zip</span><span class=\"token punctuation\">(</span>source1$<span class=\"token punctuation\">,</span> source2$<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//[1,\"a\"] [2,\"b\"] [3,\"c\"]</span></code></pre></div>\n<ul>\n<li>\n<p>数据积压问题如果合并的几条数据流有的吐数据很快，有的很慢，zip 就不得不先储存吐的快的数据，这时候 zip 积压的数据会越来越多，占用的内存也就越来越多。zip 操作符自身解决不了这个问题，后面再研究。</p>\n</li>\n<li>\n<p>zip 多个数据流\nzip 合并多条数据流时，数据最少的那条数据流决定 zip 产生的数据个数</p>\n</li>\n</ul>\n<h1>combineLastest</h1>\n<p>既有静态操作符也有实例操作符。合并最后一个数据(最新数据)，只要有一条数据流的数据更新了就会吐出最新数据,所有数据流完结后，combineLastest 才会给下游完结信号，表示不会有任何数据更新了。</p>\n<ul>\n<li>如果合并的数据流都是异步的，弹珠图如下：\n<img src=\"http://p4yaly36s.bkt.clouddn.com/201805272209_690.png\"></li>\n<li>如果都是同步的，和 merge、zip 类似，combineLastest 是按顺序依次一口气订阅所有数据流的，但是同步数据流在 <strong>刚订阅的时候就直接吐出所有数据</strong> 了，所以最后一跳数据流之前的同步数据流都直接是 <strong>最新数据</strong>。例子：</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> combineLastest <span class=\"token keyword\">as</span> CombineLastest <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'rxjs'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> source1$ <span class=\"token operator\">=</span> <span class=\"token keyword\">of</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> source2$ <span class=\"token operator\">=</span> <span class=\"token keyword\">of</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> source$ <span class=\"token operator\">=</span> <span class=\"token function\">CombineLastest</span><span class=\"token punctuation\">(</span>source1$<span class=\"token punctuation\">,</span> source2$<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//[3,4] [3,5] [3,6]</span></code></pre></div>\n<ul>\n<li>定制下游数据\ncombineLastest 的最后一个参数可以是一个函数（可选），称之为 project，作用是吧所有上游的“最新数据”扔给下游之前做一下组合处理，这样可以不用传递一个数组，而是任何由“最新数据”产生的对象或者其他自定义结果。</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> source1$ <span class=\"token operator\">=</span> <span class=\"token keyword\">of</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> source2$ <span class=\"token operator\">=</span> <span class=\"token keyword\">of</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> source$ <span class=\"token operator\">=</span> <span class=\"token function\">CombineLastest</span><span class=\"token punctuation\">(</span>source1$<span class=\"token punctuation\">,</span> source2$<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> x<span class=\"token punctuation\">,</span> y <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//{x:3,y:4} {x:3,y:5} {x:3,y:6}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">zip和combineLastest一样有可选参数用来定制输出数据。当然，也可以用map处理合并后的数组。</code></pre></div>\n<ul>\n<li>多重依赖问题\ncombineLastest 产生的数据依赖于上游的多个数据流，如果上游的多个数据流又共同依赖于另一个数据流，这就是多重依赖问题</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> original$ <span class=\"token operator\">=</span> <span class=\"token function\">timer</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> source1$ <span class=\"token operator\">=</span> original$ <span class=\"token operator\">|</span><span class=\"token operator\">></span> <span class=\"token function\">map</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">=></span> x <span class=\"token operator\">+</span> <span class=\"token string\">'a'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> source2$ <span class=\"token operator\">=</span> original$ <span class=\"token operator\">|</span><span class=\"token operator\">></span> <span class=\"token function\">map</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">=></span> x <span class=\"token operator\">+</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> source$ <span class=\"token operator\">=</span> <span class=\"token function\">CombineLastest</span><span class=\"token punctuation\">(</span>source1$<span class=\"token punctuation\">,</span> source2$<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">这个例子不会像预期那样每隔一秒输出一组数据，具体自信执行试验。\n这种现象可以说是Rxjs的缺陷，原因是 **虽然逻辑上这2个数据流是同时的，但是其实差了几纳秒** 。\n要解决这个问题也很简单，我们选错了操作符罢了，这情况应该用withLastestFrom</code></pre></div>\n<h1>withLatestFrom</h1>\n<p>只有实例操作符。功能类似于 combineLastest，但是 withLastestFrom <strong>吐数据节奏是由调用它的数据流主导</strong> 的。弹珠图如下：\n<img src=\"http://p4yaly36s.bkt.clouddn.com/201805272305_770.png\"></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> withLastestFrom <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'rxjs/operators'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> source1$ <span class=\"token operator\">=</span> <span class=\"token function\">timer</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2000</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">|</span><span class=\"token operator\">></span> <span class=\"token function\">map</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">=></span> <span class=\"token number\">100</span> <span class=\"token operator\">*</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> source2$ <span class=\"token operator\">=</span> <span class=\"token function\">timer</span><span class=\"token punctuation\">(</span><span class=\"token number\">500</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> source$ <span class=\"token operator\">=</span> source1$ <span class=\"token operator\">|</span><span class=\"token operator\">></span> <span class=\"token function\">withLatestFrom</span><span class=\"token punctuation\">(</span>source2$<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//101 203 305 407 ...</span></code></pre></div>\n<p>所有百分位都是由 source1$产生的，所有个位都是由 source2$产生的，每隔 2 秒吐出一个数据，可以很清楚的看到 source1$占了主导地位。所以用 combineLastest 产生多重依赖问题的例子可以用 withLatestFrom 解决：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> withLastestFrom <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'rxjs/operators'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> original$ <span class=\"token operator\">=</span> <span class=\"token function\">timer</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> source1$ <span class=\"token operator\">=</span> original$ <span class=\"token operator\">|</span><span class=\"token operator\">></span> <span class=\"token function\">map</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">=></span> x <span class=\"token operator\">+</span> <span class=\"token string\">'a'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> source2$ <span class=\"token operator\">=</span> original$ <span class=\"token operator\">|</span><span class=\"token operator\">></span> <span class=\"token function\">map</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">=></span> x <span class=\"token operator\">+</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> source$ <span class=\"token operator\">=</span> source1$ <span class=\"token operator\">|</span><span class=\"token operator\">></span> <span class=\"token function\">withLastestFrom</span><span class=\"token punctuation\">(</span>source2$<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>combineLastest 和 withLatestFrom 的选择：</p>\n<ul>\n<li>如果要合并完全独立的数据流，用 combineLastest</li>\n<li>如果要吧一个数据流“映射”成一个新的数据流，同时要从其他数据流获取“最新数据”，用 withlatestFrom</li>\n</ul>\n<h1>race</h1>\n<p>既有静态操作符也有实例操作符。第一个吐出数据的数据流获得胜利，race 产生的数据流会完全采用胜者数据流的数据，其余的数据流会被退订。<strong>竞争是公平的，结果和参数顺序完全没有关系</strong></p>\n<h1>startWith</h1>\n<p>只有实例操作符。在一个数据流被订阅时先吐出若干个指定数据。startWith 吐出的数据是同步的，想吐出异步数据可以用 concat。其实 startWith 完全可以用 concat 实现，但是无论静态 concat 还是实例 concat，“被塞进数据”的数据流只能当做参数（因为要塞在开头），这样就没法链式调用了，所以有了 startWith。</p>\n<h1>forkJoin</h1>\n<p>只有静态操作符。接收多个数据流，等待所有数据流吐出最后一个数据（完结）后，forkjoin 回吧所有输入的数据流产生的最后一个数据合并一个数据扔给下游。功能类比于 Promise.all。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> forkJoin <span class=\"token keyword\">as</span> ForkJoin <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'rxjs'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> source1$ <span class=\"token operator\">=</span> <span class=\"token function\">interval</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">|</span><span class=\"token operator\">></span> <span class=\"token function\">map</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">=></span> x <span class=\"token operator\">+</span> <span class=\"token string\">'a'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">|</span><span class=\"token operator\">></span> <span class=\"token function\">take</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> source2$ <span class=\"token operator\">=</span> <span class=\"token function\">interval</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">|</span><span class=\"token operator\">></span> <span class=\"token function\">map</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">=></span> x <span class=\"token operator\">+</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">|</span><span class=\"token operator\">></span> <span class=\"token function\">take</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> source$ <span class=\"token operator\">=</span> <span class=\"token function\">ForkJoin</span><span class=\"token punctuation\">(</span>source1$<span class=\"token punctuation\">,</span> source2$<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//3s后输出[\"0a\", \"2b\"]</span></code></pre></div>\n<h1><strong>接下来是一些高阶 Observable 合并类操作符</strong></h1>\n<h1>concatAll</h1>\n<p>只有静态操作符。对上游的高阶 Observable 的所有内部 Observable 做 concat 的操作。\n<strong>注意：</strong>concatAll 会依次订阅每个内部 Observable，只有上一个内部 Observable 完结了再会继续订阅下一个，如果其中有一个内部 Observable 永不完结，会造成后续 <strong>内部 Observable</strong> 的堆积从而造成内存泄漏</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> source$ <span class=\"token operator\">=</span>\n  <span class=\"token function\">interval</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">|</span><span class=\"token operator\">></span> <span class=\"token function\">take</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">|</span><span class=\"token operator\">></span> <span class=\"token function\">map</span><span class=\"token punctuation\">(</span>a <span class=\"token operator\">=></span> <span class=\"token function\">interval</span><span class=\"token punctuation\">(</span><span class=\"token number\">1500</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">|</span><span class=\"token operator\">></span> <span class=\"token function\">map</span><span class=\"token punctuation\">(</span>b <span class=\"token operator\">=></span> a <span class=\"token operator\">+</span> <span class=\"token string\">':'</span> <span class=\"token operator\">+</span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">|</span><span class=\"token operator\">></span> <span class=\"token function\">take</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">|</span><span class=\"token operator\">></span> <span class=\"token function\">concatAll</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nsource$<span class=\"token punctuation\">.</span><span class=\"token function\">subscribe</span><span class=\"token punctuation\">(</span>a <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'done'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 0:0 0:1 1:0 1:1</span></code></pre></div>\n<h1>zipAll</h1>\n<p>只有静态操作符。一对一合并上游高阶 Observable 的内部 Observable。\n<strong>如果上游高阶 Observable 不完结，zipAll 不会开始工作，因为 zipAll 的工作方式是等待所有一阶 Observable 来实现一对一匹配，上游不完结表示 ZipAll 不知道还有没有新的一阶 Observable，所以它会一直等下去。</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> source$ <span class=\"token operator\">=</span>\n  <span class=\"token function\">interval</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span>\n  <span class=\"token operator\">|</span><span class=\"token operator\">></span> <span class=\"token function\">take</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n  <span class=\"token operator\">|</span><span class=\"token operator\">></span> <span class=\"token function\">concat</span><span class=\"token punctuation\">(</span><span class=\"token function\">never</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token operator\">|</span><span class=\"token operator\">></span> <span class=\"token function\">map</span><span class=\"token punctuation\">(</span>a <span class=\"token operator\">=></span> <span class=\"token function\">interval</span><span class=\"token punctuation\">(</span><span class=\"token number\">1500</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">|</span><span class=\"token operator\">></span> <span class=\"token function\">map</span><span class=\"token punctuation\">(</span>b <span class=\"token operator\">=></span> a <span class=\"token operator\">+</span> <span class=\"token string\">':'</span> <span class=\"token operator\">+</span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">|</span><span class=\"token operator\">></span> <span class=\"token function\">take</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token operator\">|</span><span class=\"token operator\">></span> <span class=\"token function\">zipAll</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nsource$<span class=\"token punctuation\">.</span><span class=\"token function\">subscribe</span><span class=\"token punctuation\">(</span>a <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'done'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// [\"0:0\", \"1:0\"] [\"0:1\", \"1:1\"]</span></code></pre></div>\n<h1>combineAll</h1>\n<p>只有静态操作符。对上游的高阶 Observable 做 combineLastest 的操作。和 zipAll 一样，如果上游高阶 Observable 不完结，它不会开始工作。</p>\n<h1>switchAll（V5 叫 switch）</h1>\n<p>concatAll、zipAll 和 combineAll 要么必须等第一个内部 Observable 完结才会继续下一个，要么需要等上游高阶 Observable 吐出所有一阶 Observable 才开始工作，这样就有了很大限制，没办法想获取哪条内部数据流里的数据就获取。\nswitch 操作符总是切换到最新的内部数据流获取数据，每当上游高阶 Observable 产生一个内部数据流，switch 就会退订上一个 Observable，然后订阅新的内部 Observable 并开始吐出它的数据。换句话说，<strong>switchAll 可以把高阶 Observable 转换为一阶 Observable。</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> source$ <span class=\"token operator\">=</span>\n  <span class=\"token function\">interval</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">|</span><span class=\"token operator\">></span> <span class=\"token function\">take</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">|</span><span class=\"token operator\">></span> <span class=\"token function\">map</span><span class=\"token punctuation\">(</span>a <span class=\"token operator\">=></span> <span class=\"token function\">interval</span><span class=\"token punctuation\">(</span><span class=\"token number\">1500</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">|</span><span class=\"token operator\">></span> <span class=\"token function\">map</span><span class=\"token punctuation\">(</span>b <span class=\"token operator\">=></span> a <span class=\"token operator\">+</span> <span class=\"token string\">':'</span> <span class=\"token operator\">+</span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">|</span><span class=\"token operator\">></span> <span class=\"token function\">take</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">|</span><span class=\"token operator\">></span> <span class=\"token function\">switchAll</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//2:0 2:1</span></code></pre></div>\n<p><img src=\"http://p4yaly36s.bkt.clouddn.com/201805292340_526.png\">\n上面的例子中，每次切到新的内部数据流，还没开始吐数据，就又切到新的内部数据流了，所以最终输出是 2:0 2:1</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> source$ <span class=\"token operator\">=</span> <span class=\"token function\">interval</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">|</span><span class=\"token operator\">></span> <span class=\"token function\">take</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">|</span><span class=\"token operator\">></span> <span class=\"token function\">map</span><span class=\"token punctuation\">(</span>a <span class=\"token operator\">=></span> <span class=\"token function\">interval</span><span class=\"token punctuation\">(</span><span class=\"token number\">800</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">|</span><span class=\"token operator\">></span> <span class=\"token function\">map</span><span class=\"token punctuation\">(</span>b <span class=\"token operator\">=></span> a <span class=\"token operator\">+</span> <span class=\"token string\">':'</span> <span class=\"token operator\">+</span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">|</span><span class=\"token operator\">></span> <span class=\"token function\">take</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">|</span><span class=\"token operator\">></span> <span class=\"token function\">switchAll</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//0:0 1:0 2:0 2:1</span></code></pre></div>\n<div class=\"divider\"></div>\n<p><img src=\"http://p4yaly36s.bkt.clouddn.com/201805292340_540.png\">\n上面的例子中，每次切到新的内部数据流后吐出一个数据才切到下一个新的内部数据流，所以最终输出是 0:0 1:0 2:0 2:1</p>\n<blockquote>\n<p>也就是说，如果内部 Observable 吐得比上游高阶 Observable 快，那么新产生的 Observable 就会吐出第一个甚至更多的数据，最后会持续吐出最新的内部 Observable 的数据。\n<strong>注意：只有上游高阶 Observable 和当前内部 Observable 都完结的时候，switch 才会完结，因为 switch“既有横向发展又有纵向发展”</strong></p>\n</blockquote>\n<h1>exhaust</h1>\n<p>和 switchAll 相反，exhaust 会在产生新的内部 Observable 时判断老的内部 Observable 是否已完结，如果没完结，就继续老的，如果完结了，才会跳到新的内部 Observable 中。switchAll 则是只要产生新的内部 Observable 就马上跳过去。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> source$ <span class=\"token operator\">=</span> <span class=\"token function\">interval</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">|</span><span class=\"token operator\">></span> <span class=\"token function\">take</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">|</span><span class=\"token operator\">></span> <span class=\"token function\">map</span><span class=\"token punctuation\">(</span>a <span class=\"token operator\">=></span> <span class=\"token function\">interval</span><span class=\"token punctuation\">(</span><span class=\"token number\">700</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">|</span><span class=\"token operator\">></span> <span class=\"token function\">map</span><span class=\"token punctuation\">(</span>b <span class=\"token operator\">=></span> a <span class=\"token operator\">+</span> <span class=\"token string\">':'</span> <span class=\"token operator\">+</span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">|</span><span class=\"token operator\">></span> <span class=\"token function\">take</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">|</span><span class=\"token operator\">></span> <span class=\"token function\">exhaust</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//0:0 1:0 2:0 2:1</span></code></pre></div>\n<p><img src=\"http://p4yaly36s.bkt.clouddn.com/201805292340_540.png\">\n上面例子中产生第二个内部 Observable 时第一个内部 Observable 未完结，所以第二个 Observable 被舍弃。产生第三个内部 Observable 时第一个已完结，所以跳到第三个内部 Observable 中继续吐数据。</p>","frontmatter":{"title":"Rxjs笔记（6）：合并类操作符","date":"2018.05.28"}}},"pageContext":{"slug":"/artical/rx6合并类操作符/","previous":{"frontmatter":{"title":"Rxjs笔记（7）：辅助类操作符","tags":["rxjs"]},"fields":{"slug":"/artical/rx7辅助类操作符/","tagSlugs":["/tags/rxjs/"]}},"next":{"frontmatter":{"title":"Rxjs笔记（5）：高阶Observable","tags":["rxjs"]},"fields":{"slug":"/artical/rx5高阶Observable/","tagSlugs":["/tags/rxjs/"]}}}}